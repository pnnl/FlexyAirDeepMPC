"""
TODO: eval_metric - evaluate closed loop metric based on the simulation results
use the same interface for objectives as for the problem via _calculate_loss
TODO: overwrite past after n-steps, continuously in first n steps

"""

# machine learning/data science imports
import torch
import torch.nn as nn
import numpy as np

# ecosystem imports
from psl import EmulatorBase

# lcoal imports
from neuromancer.datasets import EmulatorDataset, FileDataset, min_max_denorm
from neuromancer.problem import Problem
from neuromancer.datasets import Dataset, DataDict


class Simulator:
    def __init__(self, model: Problem, dataset: Dataset, emulator: EmulatorBase = None):
        self.model = model
        self.dataset = dataset
        self.emulator = emulator

    def dev_eval(self):
        dev_loop_output = self.model(self.dataset.dev_loop)
        return dev_loop_output

    def test_eval(self):
        all_output = dict()
        for data, dname in zip([self.dataset.train_loop, self.dataset.dev_loop, self.dataset.test_loop],
                               ['train', 'dev', 'test']):
            all_output = {**all_output, **self.simulate(data)}
        return all_output

    def simulate(self):
        pass


class OpenLoopSimulator(Simulator):
    def __init__(self, model: Problem, dataset: Dataset, emulator: [EmulatorBase, nn.Module] = None):
        super().__init__(model=model, dataset=dataset, emulator=emulator)

    def simulate(self, data):
        return self.model(data)


class ClosedLoopSimulator(Simulator):
    def __init__(self, model: Problem, dataset: Dataset, emulator: [EmulatorBase, nn.Module] = None):
        super().__init__(model=model, dataset=dataset, emulator=emulator)
        assert isinstance(emulator, EmulatorBase) or isinstance(emulator,  nn.Module), \
            f'{type(emulator)} is not EmulatorBase or nn.Module.'
        self.emulator = emulator
        self.ninit = 0
        self.nsim = self.dataset.nstep_data['Yf'].shape[1]
        if isinstance(emulator, EmulatorBase):
            self.x0 = self.emulator.x0
        elif isinstance(emulator, nn.Module):
            self.x0 = torch.zeros([1, self.emulator.nx])

    def select_step_data(self, data, i):
        """
        for closed loop we want to pick i-th batch of the nstep data nstep_data[item][:, k, :]

        :param data:
        :param i:
        :return:
        """
        step_data = DataDict()
        for k, v in data.items():
            step_data[k] = v[:, i, :].reshape(v.shape[0], 1, v.shape[2])
        step_data.name = data.name
        return step_data

    def eval_metric(self):
        pass

    def simulate(self, data):
        """
          # CL eval steps:
          # 1, initialize emulator with initial conditions and initial input trajectories
          # 2, obtain i-th simulation step batch of nstep data generated by emulator
          # 3, forward pass i-th step batch through the model
          # 4, receding horizon - slect only first sampling instant of the i-th batch control actions
          # 5, simulate emulator with selected control actions and obtain new step batch - continue from step 2,

        :param data:
        :return:
        """
        self.model.eval()
        self.nsim = data['Yp'].shape[1]
        self.nsteps = data['Yp'].shape[0]
        Y, X, D, U, R = [], [], [], [], []  # emulator trajectories
        Ymin, Ymax, Umin, Umax = [], [], [], []
        Y_pred, X_pred, U_pred, U_opt = [], [], [], []   # model  trajectories
        for i in range(self.nsim):
            step_data = self.select_step_data(data, i)

            x = self.x0 if i == 0 else x
            if i > 0:
                # select current step disturbance, reference and constraints
                d = step_data['Df'][0].detach().numpy() if step_data['Df'] is not None else None
                r = step_data['Rf'][0].detach().numpy() if step_data['Rf'] is not None else None
                ymin = step_data['Y_minf'][0].detach().numpy() if step_data['Y_minf'] is not None else None
                ymax = step_data['Y_maxf'][0].detach().numpy() if step_data['Y_maxf'] is not None else None
                umin = step_data['U_minf'][0].detach().numpy() if step_data['U_minf'] is not None else None
                umax = step_data['U_maxf'][0].detach().numpy() if step_data['U_maxf'] is not None else None
                if 'Y' in self.dataset.norm:
                    r = min_max_denorm(r, self.dataset.min_max_norms['Ymin'],
                                       self.dataset.min_max_norms['Ymax']) if r is not None else None
                    ymin = min_max_denorm(ymin, self.dataset.min_max_norms['Ymin'],
                                       self.dataset.min_max_norms['Ymax']) if ymin is not None else None
                    ymax = min_max_denorm(ymax, self.dataset.min_max_norms['Ymin'],
                                          self.dataset.min_max_norms['Ymax']) if ymax is not None else None
                if 'U' in self.dataset.norm:
                    umin = min_max_denorm(umin, self.dataset.min_max_norms['Umin'],
                                       self.dataset.min_max_norms['Umax']) if umin is not None else None
                    umax = min_max_denorm(umax, self.dataset.min_max_norms['Umin'],
                                          self.dataset.min_max_norms['Umax']) if umax is not None else None
                if 'D' in self.dataset.norm:
                    d = min_max_denorm(d, self.dataset.min_max_norms['Dmin'],
                                       self.dataset.min_max_norms['Dmax']) if d is not None else None
                # simulate 1 step of the emulator model
                if isinstance(self.emulator, EmulatorBase):
                    x, y, _, _ = self.emulator.simulate(ninit=0, nsim=1, U=u, D=d, x0=x.flatten())
                elif isinstance(self.emulator, nn.Module):
                    step_data_0 = dict()
                    step_data_0['U_pred_policy'] = uopt.reshape(uopt.shape[0], uopt.shape[1], 1)
                    step_data_0['x0_estim'] = x
                    for k, v in step_data.items():
                        dat = v[0]
                        step_data_0[k] = dat.reshape(dat.shape[0], dat.shape[1], 1)
                    emulator_output = self.emulator(step_data_0)
                    x = emulator_output['X_pred_dynamics'][0]
                    y = emulator_output['Y_pred_dynamics'][0].detach().numpy()
                    if 'Y' in self.dataset.norm:
                        y = min_max_denorm(y, self.dataset.min_max_norms['Ymin'],
                                           self.dataset.min_max_norms['Ymax']) if y is not None else None
                # update u and y trajectory history
                if len(Y) > self.nsteps:
                    if 'Y' in self.dataset.norm and isinstance(self.emulator, EmulatorBase):
                        Yp_np, _, _ = self.dataset.normalize(np.concatenate(Y[-self.nsteps:]),
                                                             Mmin=self.dataset.min_max_norms['Ymin'],
                                                             Mmax=self.dataset.min_max_norms['Ymax'])
                    else:
                        Yp_np = np.concatenate(Y[-self.nsteps:])
                    step_data['Yp'] = torch.tensor(np.concatenate(Yp_np, 0)).reshape(self.nsteps, 1, -1)

                if len(U_opt) > self.nsteps:
                    step_data['Up'] = torch.cat(U_opt[-self.nsteps:], dim=0).reshape(self.nsteps, 1, -1)

            # control policy model
            step_output = self.model(step_data)

            # model trajectories
            x_key = [k for k in step_output.keys() if 'X_pred' in k]
            X_pred.append(step_output[x_key[0]])
            y_key = [k for k in step_output.keys() if 'Y_pred' in k]
            Y_pred.append(step_output[y_key[0]])
            u_key = [k for k in step_output.keys() if 'U_pred' in k]
            U_pred.append(step_output[u_key[0]])
            uopt = step_output[u_key[0]][0].detach()
            U_opt.append(uopt)

            # emulator trajectories
            if 'U' in self.dataset.norm:
                u = min_max_denorm(uopt.numpy(), self.dataset.min_max_norms['Umin'],
                                   self.dataset.min_max_norms['Umax'])
            else:
                u = uopt.numpy()
            if i > 0:
                U.append(u)
                Y.append(y)
                X.append(x) if isinstance(self.emulator, EmulatorBase) else X.append(x.detach().numpy())
                D.append(d) if d is not None else None
                R.append(r) if r is not None else None
                Ymin.append(ymin) if ymin is not None else None
                Ymax.append(ymax) if ymax is not None else None
                Umin.append(umin) if umin is not None else None
                Umax.append(umax) if umax is not None else None

        return {'X_pred': torch.cat(X_pred, dim=1), 'Y_pred': torch.cat(Y_pred, dim=1),
                'U_pred': torch.cat(U_pred, dim=1), 'U_opt': torch.cat(U_opt, dim=0),
                'Y': np.concatenate(Y, 0), 'X': np.concatenate(X, 0), 'U': np.concatenate(U, 0),
                'D': np.concatenate(D, 0) if D is not None else None,
                'R': np.concatenate(R, 0) if R is not None else None,
                'Ymin': np.concatenate(Ymin, 0) if Ymin is not None else None,
                'Ymax': np.concatenate(Ymax, 0) if Ymax is not None else None,
                'Umin': np.concatenate(Umin, 0) if Umin is not None else None,
                'Umax': np.concatenate(Umax, 0) if Umax is not None else None}


if __name__ == '__main__':

    systems = {'Reno_full': 'emulator'}
    for system, data_type in systems.items():
        if data_type == 'emulator':
            dataset = EmulatorDataset(system)
        elif data_type == 'datafile':
            dataset = FileDataset(system)
    nsim, ny = dataset.data['Y'].shape
    nu = dataset.data['U'].shape[1]
